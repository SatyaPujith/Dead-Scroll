# Design Document - Dead Scroll Horror Website Blocker

## Overview

Dead Scroll is a Chrome Manifest V3 extension that combines behavioral psychology, horror aesthetics, and AI-powered education to help users break digital addictions. The system intercepts navigation to blocked websites and requires users to complete educational quests generated by Google's Gemini AI before granting access.

The design follows a three-layer architecture: (1) React-based user interface for the popup and blocking screens, (2) Chrome background service worker for navigation monitoring and blocking logic, and (3) external AI integration for dynamic content generation.

## Architecture

### High-Level System Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                     Chrome Browser                           │
│  ┌────────────────┐         ┌──────────────────────┐       │
│  │  Extension     │         │   Background         │       │
│  │  Popup (React) │◄────────┤   Service Worker     │       │
│  │                │         │                      │       │
│  │  - Dashboard   │         │  - URL Monitoring    │       │
│  │  - Graveyard   │         │  - Blocking Logic    │       │
│  │  - Burial Form │         │  - Storage Sync      │       │
│  └────────┬───────┘         └──────────┬───────────┘       │
│           │                            │                    │
│  ┌────────▼───────┐         ┌──────────▼───────────┐       │
│  │  Horror Block  │         │   Chrome Storage     │       │
│  │  Interface     │         │   API                │       │
│  │                │         │                      │       │
│  │  - Block Screen│         │  - Buried Sites      │       │
│  │  - Quest UI    │         │  - Temp Unlocks      │       │
│  └────────┬───────┘         └──────────────────────┘       │
│           │                                                 │
│  ┌────────▼───────┐                                        │
│  │  Learning Quest│                                        │
│  │  Component     │                                        │
│  │                │                                        │
│  │  - Topic Input │                                        │
│  │  - Content View│                                        │
│  │  - Quiz Combat │                                        │
│  └────────┬───────┘                                        │
└───────────┼─────────────────────────────────────────────────┘
            │
            │ HTTPS
            ▼
┌───────────────────────────────────────────────────────────┐
│         Google Gemini API (External)                       │
│                                                            │
│  - Content Generation                                     │
│  - Educational Sections                                   │
│  - Quiz Questions                                         │
└───────────────────────────────────────────────────────────┘
```

### Component Interaction Flow

1. **Burial Flow**: User enters URL in popup → Data stored in Chrome storage → Background service starts monitoring
2. **Blocking Flow**: User navigates to buried site → Background service detects → Redirects to horror block interface
3. **Quest Flow**: User initiates quest → Gemini API generates content → User completes sections → Site unlocked and removed from graveyard
4. **Storage Sync**: All components read/write to Chrome storage API for state synchronization

## Components and Interfaces

### 1. Main Dashboard Component (App.tsx)

**Purpose**: Primary extension interface for managing buried websites

**State Interface**:
```typescript
interface BuriedSite {
  id: string;           // UUID for unique identification
  name: string;         // Display name (e.g., "instagram.com")
  url: string;          // Full URL for matching
  buriedAt: number;     // Unix timestamp of burial
  unlockAt: number;     // Unix timestamp when burial expires
  attempts: number;     // Count of failed access attempts
}

type ViewState = 'dashboard' | 'ritual' | 'horror';
```

**Key Functions**:
- `handleBurySite(name: string, days: number)`: Creates burial entry and triggers ritual animation
- `handleDeleteSite(id: string)`: Removes site from graveyard with confirmation
- `handleVisitSite(site: BuriedSite)`: Opens horror block or site based on status
- `checkDuplicates(name: string)`: Prevents duplicate burials

**UI Sections**:
- Header with branding and horror typography
- Burial form with URL input and duration slider (1-365 days)
- Graveyard list with site cards showing status, time remaining, and attempts
- Action buttons for visiting and deleting sites

### 2. Horror Block Component (HorrorBlock.tsx)

**Purpose**: Immersive blocking interface with quest initiation

**Props Interface**:
```typescript
interface HorrorBlockProps {
  siteName: string;      // Name of blocked site
  onUnblock: () => void; // Callback when quest completed
  onGiveUp: () => void;  // Callback when user exits
}
```

**State Management**:
```typescript
type ViewState = 'block' | 'quest';
```

**Visual Elements**:
- Full-screen dark background with red gradients
- Animated scanline effects
- Site name display with skull icons
- "LEARN TO ESCAPE" primary action button
- "I Remain Strong" secondary exit button

**Behavior**:
- Displays blocking message on load
- Transitions to quest view when user clicks "LEARN TO ESCAPE"
- Returns to dashboard when quest completed or user exits

### 3. Learning Quest Component (LearningQuest.tsx)

**Purpose**: AI-powered educational challenge system

**Props Interface**:
```typescript
interface LearningQuestProps {
  onComplete: () => void;  // Callback when quest completed
  siteName: string;        // Name of blocked site
}
```

**Content Structure**:
```typescript
interface ContentSection {
  title: string;           // Section heading (3-5 words)
  content: string;         // Educational paragraphs
  quiz: {
    question: string;      // Quiz question
    options: string[];     // 4 multiple choice options
    correctAnswer: number; // Index of correct answer (0-3)
  };
}
```

**Game State Machine**:
```typescript
type GameState = 'input' | 'generating' | 'reading' | 'combat' | 'victory';
```

**State Transitions**:
- `input` → User enters topic → `generating`
- `generating` → API returns content → `reading`
- `reading` → User clicks "FACE THE GHOST" → `combat`
- `combat` → Correct answer → Next section or `victory`
- `combat` → Wrong answer → Retry same quiz
- `combat` → No hearts remaining → Reset to `input`
- `victory` → Callback to unlock site

**Health System**:
- Player starts with 3 hearts
- Wrong answer deducts 1 heart
- Zero hearts triggers quest restart
- Health resets on new quest

### 4. Background Service Worker (background.js)

**Purpose**: Navigation monitoring and blocking enforcement

**Core Functions**:
```javascript
// URL matching logic
function isUrlBlocked(currentUrl, blockedUrl) {
  // Extract domains and compare
  // Returns boolean indicating if URL should be blocked
}

// Main blocking check
function shouldBlockSite(url, callback) {
  // Retrieves buried sites from storage
  // Checks for matches
  // Verifies temporary unlock status
  // Returns blocking decision
}

// Navigation listener
chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
  // Monitors tab loading events
  // Redirects to horror block if site is buried
});
```

**Storage Management**:
```javascript
// Buried sites storage key
const STORAGE_KEY = 'skinnerbox_graves';

// Temporary unlocks storage key
const TEMP_UNLOCK_KEY = 'skinnerbox_temp_unlocks';
```

**Cleanup Operations**:
- Periodic removal of expired temporary unlocks
- Storage quota monitoring
- Error recovery for corrupted data

### 5. Storage Service (storageService.ts)

**Purpose**: Abstraction layer for Chrome storage operations

**API Functions**:
```typescript
// Retrieve all buried sites
export async function getBuriedSites(): Promise<BuriedSite[]>

// Save buried sites array
export async function saveBuriedSites(sites: BuriedSite[]): Promise<void>

// Add new burial
export async function burySite(site: BuriedSite): Promise<void>

// Remove site from graveyard
export async function excavateSite(id: string): Promise<void>

// Increment attempt counter
export async function incrementAttempts(id: string): Promise<void>

// Grant temporary access
export async function grantTempAccess(id: string, duration: number): Promise<void>

// Check if site has temp unlock
export async function hasTempUnlock(id: string): Promise<boolean>
```

**Error Handling**:
- Wraps Chrome storage API calls in try-catch blocks
- Provides fallback values for failed reads
- Logs errors for debugging
- Notifies user of critical failures

## Data Models

### BuriedSite Model

```typescript
interface BuriedSite {
  id: string;           // UUID v4 format
  name: string;         // User-friendly display name
  url: string;          // Full URL with protocol
  buriedAt: number;     // Unix timestamp (milliseconds)
  unlockAt: number;     // Unix timestamp (milliseconds)
  attempts: number;     // Non-negative integer
}
```

**Validation Rules**:
- `id`: Must be valid UUID
- `name`: Non-empty string, max 100 characters
- `url`: Valid URL format, must include domain
- `buriedAt`: Must be ≤ current time
- `unlockAt`: Must be > buriedAt
- `attempts`: Must be ≥ 0

**Storage Format**:
```json
{
  "skinnerbox_graves": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "name": "instagram.com",
      "url": "https://instagram.com",
      "buriedAt": 1699123456789,
      "unlockAt": 1699209856789,
      "attempts": 3
    }
  ]
}
```

### Temporary Unlock Model

```typescript
interface TempUnlock {
  expiresAt: number;    // Unix timestamp (milliseconds)
}

type TempUnlockMap = Record<string, TempUnlock>;
```

**Storage Format**:
```json
{
  "skinnerbox_temp_unlocks": {
    "550e8400-e29b-41d4-a716-446655440000": {
      "expiresAt": 1699124056789
    }
  }
}
```

### Educational Content Model

```typescript
interface EducationalContent {
  sections: ContentSection[];
}

interface ContentSection {
  title: string;        // 3-5 words
  content: string;      // 2-3 paragraphs, ~200-400 words
  quiz: QuizQuestion;
}

interface QuizQuestion {
  question: string;     // Clear, specific question
  options: string[];    // Exactly 4 options
  correctAnswer: number; // 0-3 index
}
```

**Content Generation Prompt**:
```
Create an educational lesson about "${topic}" divided into 5 sections.
Each section should teach something important about the topic, 
progressing from basics to advanced concepts.

For each section provide:
1. A short title (3-5 words)
2. Educational content (2-3 informative paragraphs)
3. A multiple choice quiz question with 4 options

Format as JSON with sections array...
```

## Correctness Properties

*A property is a characteristic or behavior that should hold true across all valid executions of a system-essentially, a formal statement about what the system should do. Properties serve as the bridge between human-readable specifications and machine-verifiable correctness guarantees.*

### Property 1: Burial Creation Consistency
*For any* valid website URL and duration, creating a burial should result in exactly one new entry in the graveyard with correct timestamps where unlockAt = buriedAt + (days * 86400000)
**Validates: Requirements 1.1**

### Property 2: Duplicate Prevention
*For any* website that already exists in the graveyard, attempting to bury it again should not create a new entry and should notify the user
**Validates: Requirements 1.2**

### Property 3: URL Matching Correctness
*For any* buried site URL and navigation URL, the blocking decision should be consistent regardless of protocol (http/https), subdomain variations, or path differences when the domain matches
**Validates: Requirements 2.2**

### Property 4: Attempt Counter Monotonicity
*For any* buried site, the attempts counter should only increase (never decrease) and should increment by exactly 1 for each blocked access attempt
**Validates: Requirements 2.4**

### Property 5: Quest Content Structure Validity
*For any* generated educational content, it must contain exactly 5 sections, each with a non-empty title, content, and quiz with exactly 4 options and a valid correctAnswer index (0-3)
**Validates: Requirements 4.3**

### Property 6: Health System Consistency
*For any* quiz combat session, the player health should start at 3, decrease by 1 for each wrong answer, and trigger quest restart when reaching 0
**Validates: Requirements 5.2, 5.3**

### Property 7: Quest Completion Unlocking
*For any* successfully completed quest (all 5 sections answered correctly), the corresponding site should be removed from the graveyard and become immediately accessible
**Validates: Requirements 7.1, 7.2**

### Property 8: Storage Persistence
*For any* burial operation, the data should persist across browser sessions such that retrieving buried sites after a restart returns the same data
**Validates: Requirements 10.1, 10.2**

### Property 9: Animation Frame Rate
*For any* animation sequence, the frame rate should maintain at least 50 FPS (allowing 10 FPS tolerance from 60 FPS target) under normal system load
**Validates: Requirements 11.2**

### Property 10: Error Recovery Graceful Degradation
*For any* API failure or network error, the extension should continue functioning with appropriate error messages and should not crash or become unresponsive
**Validates: Requirements 12.2, 12.4**

### Property 11: Sound Effect Playback
*For any* quiz answer submission, the appropriate sound effect (correct or wrong) should play unless audio context initialization has failed
**Validates: Requirements 6.1, 6.2, 6.5**

### Property 12: Graveyard Display Completeness
*For any* set of buried sites in storage, the graveyard view should display all sites with their complete information (name, URL, dates, attempts) without omissions
**Validates: Requirements 1.3**

## Error Handling

### API Integration Errors

**Gemini API Failures**:
- **Missing API Key**: Display setup instructions with link to Google AI Studio
- **Invalid API Key**: Show authentication error with key validation steps
- **Rate Limiting (429)**: Display retry message with exponential backoff
- **Network Timeout**: Show network error with manual retry button
- **Malformed Response**: Log error, show generic failure message, allow retry

**Error Recovery Strategy**:
```typescript
try {
  const content = await generateContent(topic);
  setSections(content.sections);
} catch (error) {
  if (error.status === 401 || error.status === 403) {
    setError('Invalid API key. Please check your Gemini API key.');
  } else if (error.status === 429) {
    setError('API rate limit exceeded. Please try again later.');
  } else {
    setError('Failed to generate content. Please try again.');
  }
  // Allow user to retry without losing state
}
```

### Storage Errors

**Chrome Storage Failures**:
- **Quota Exceeded**: Notify user, suggest removing old burials
- **Permission Denied**: Show permission error, link to extension settings
- **Corrupted Data**: Clear corrupted entries, log for debugging
- **Read Failures**: Use empty array fallback, notify user

**Data Validation**:
```typescript
function validateBuriedSite(site: any): site is BuriedSite {
  return (
    typeof site.id === 'string' &&
    typeof site.name === 'string' &&
    typeof site.url === 'string' &&
    typeof site.buriedAt === 'number' &&
    typeof site.unlockAt === 'number' &&
    typeof site.attempts === 'number' &&
    site.attempts >= 0
  );
}
```

### User Input Errors

**Form Validation**:
- **Empty URL**: Prevent submission, show inline error
- **Invalid URL Format**: Auto-correct common mistakes (add .com, add https://)
- **Invalid Duration**: Clamp to 1-365 range
- **Empty Topic**: Prevent quest start, show placeholder hint

**Validation Functions**:
```typescript
function validateUrl(input: string): string {
  let url = input.trim();
  if (!url) throw new Error('URL cannot be empty');
  if (!url.includes('.')) url += '.com';
  if (!url.startsWith('http')) url = 'https://' + url;
  return url;
}
```

### Runtime Errors

**Component Error Boundaries**:
- Wrap major components in error boundaries
- Display fallback UI on component crash
- Log error details for debugging
- Provide recovery actions (reload, reset)

**Audio Context Errors**:
- Gracefully handle audio initialization failures
- Continue quest without sound effects
- Log audio errors for debugging
- Don't block user progress

## Testing Strategy

### Unit Testing Approach

**Core Logic Tests**:
- URL matching algorithm with various domain formats
- Burial creation and validation
- Duplicate detection logic
- Attempt counter incrementation
- Storage service CRUD operations
- Date/time calculations for burial periods

**Component Tests**:
- Dashboard rendering with different site counts
- Horror block state transitions
- Quest state machine progression
- Form validation logic
- Error message display

**Test Framework**: Jest with React Testing Library

**Example Test Structure**:
```typescript
describe('URL Matching', () => {
  test('matches domain regardless of protocol', () => {
    expect(isUrlBlocked('https://example.com', 'http://example.com')).toBe(true);
  });
  
  test('matches subdomain variations', () => {
    expect(isUrlBlocked('www.example.com', 'example.com')).toBe(true);
  });
  
  test('does not match different domains', () => {
    expect(isUrlBlocked('example.com', 'different.com')).toBe(false);
  });
});
```

### Integration Testing

**End-to-End Flows**:
1. **Burial Flow**: Add site → Verify storage → Check graveyard display
2. **Blocking Flow**: Navigate to buried site → Verify redirect → Check attempt increment
3. **Quest Flow**: Start quest → Generate content → Answer quizzes → Verify unlock
4. **Deletion Flow**: Delete site → Verify storage removal → Check accessibility

**Chrome Extension Testing**:
- Load extension in test Chrome instance
- Verify manifest permissions
- Test background service worker
- Validate content security policy
- Check cross-component communication

### Property-Based Testing

**Testing Library**: fast-check (JavaScript property testing)

**Property Test Examples**:

```typescript
// Property 1: Burial timestamps are always consistent
fc.assert(
  fc.property(
    fc.string(), // URL
    fc.integer({ min: 1, max: 365 }), // Days
    (url, days) => {
      const site = createBurial(url, days);
      const expectedUnlock = site.buriedAt + (days * 86400000);
      return site.unlockAt === expectedUnlock;
    }
  )
);

// Property 3: URL matching is symmetric
fc.assert(
  fc.property(
    fc.webUrl(),
    fc.webUrl(),
    (url1, url2) => {
      return isUrlBlocked(url1, url2) === isUrlBlocked(url2, url1);
    }
  )
);

// Property 6: Health never goes negative
fc.assert(
  fc.property(
    fc.array(fc.boolean()), // Array of correct/wrong answers
    (answers) => {
      let health = 3;
      for (const correct of answers) {
        if (!correct) health = Math.max(0, health - 1);
        if (health === 0) break;
      }
      return health >= 0;
    }
  )
);
```

**Property Test Configuration**:
- Minimum 100 iterations per property
- Shrinking enabled for counterexample minimization
- Seed-based reproducibility for debugging
- Timeout of 5 seconds per property

### Manual Testing Checklist

**Installation & Setup**:
- [ ] Extension loads without errors
- [ ] Manifest permissions are correct
- [ ] API key setup works
- [ ] Icon displays properly

**Core Functionality**:
- [ ] Can bury websites
- [ ] Duplicate prevention works
- [ ] Sites appear in graveyard
- [ ] Blocking redirects correctly
- [ ] Quest generates content
- [ ] Quiz combat works
- [ ] Victory unlocks site
- [ ] Deletion removes sites

**UI/UX**:
- [ ] Horror theme is consistent
- [ ] Animations are smooth
- [ ] Fonts load correctly
- [ ] Responsive layout works
- [ ] Error messages are clear

**Edge Cases**:
- [ ] Empty graveyard displays correctly
- [ ] API failures are handled
- [ ] Network errors don't crash
- [ ] Invalid URLs are corrected
- [ ] Storage quota is managed

### Performance Testing

**Metrics to Monitor**:
- Extension popup load time (target: <100ms)
- Background service CPU usage (target: <1%)
- Memory consumption (target: <50MB)
- Animation frame rate (target: 60 FPS)
- API response time (target: <3s)
- Bundle size (target: <400KB)

**Performance Test Tools**:
- Chrome DevTools Performance profiler
- Lighthouse extension audit
- Bundle analyzer for size optimization
- Network throttling for API testing

### Security Testing

**Security Checks**:
- [ ] No hardcoded API keys in source
- [ ] CSP prevents inline scripts
- [ ] Storage data is validated
- [ ] XSS prevention in user inputs
- [ ] HTTPS-only API communication
- [ ] No sensitive data in logs

**Penetration Testing**:
- Attempt to bypass blocking via URL manipulation
- Test for storage injection attacks
- Verify CSP enforcement
- Check for exposed API endpoints

---

**Design Status**: Complete and Ready for Implementation ✅
**Last Updated**: November 2024
**Architecture**: Chrome Manifest V3 with React, TypeScript, and Gemini AI
